"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.QueryBase = void 0;
const assert_1 = __importDefault(require("assert"));
class QueryBase {
    constructor(driver, opts) {
        this.driver = driver;
        this.opts = opts;
    }
    async query(sql, values) {
        return this.execute(sql, values);
    }
    async queryOne(sql, values) {
        const rows = await this.execute(sql, values);
        if (rows.length !== 1 || !rows[0]) {
            throw new Error(`Expected one row, got ${rows.length} rows. Query: ${sql}`);
        }
        return rows[0];
    }
    async select(tableOrCols, tableOrCond, condOrOpts, opts) {
        let table;
        let cols;
        let cond;
        let opt;
        if (typeof tableOrCols === 'string') {
            table = tableOrCols;
            cols = '*';
            cond = tableOrCond ? tableOrCond : undefined;
            opt = condOrOpts ? condOrOpts : undefined;
        }
        else {
            cols = tableOrCols;
            table = tableOrCond;
            cond = condOrOpts ? condOrOpts : undefined;
            opt = opts;
        }
        let sql = 'SELECT';
        const values = [];
        // Apply column selection
        if (cols === '*') {
            sql += ' *';
        }
        else {
            sql += ' ' + cols.map((c) => this.strWrap(c)).join(', ');
        }
        sql += ' FROM ' + this.strWrap(table);
        if (cond) {
            sql += this.applyWhereCondition(cond, values);
        }
        if (opt === null || opt === void 0 ? void 0 : opt.order) {
            sql += this.applyOrder(opt.order);
        }
        if (opt === null || opt === void 0 ? void 0 : opt.limit) {
            sql += this.applyLimit(values, opt.limit, opt.offset);
        }
        return this.execute(sql, values);
    }
    async selectOne(tableOrCols, tableOrCond, condOrOpts, opts) {
        const rows = await this.select(tableOrCols, tableOrCond, condOrOpts, opts);
        if (rows.length !== 1 || !rows[0]) {
            throw new Error(`Expected one row, got ${rows.length} rows. Query: ${JSON.stringify({
                tableOrCols,
                tableOrCond,
                condOrOpts,
                opts,
            })}`);
        }
        return rows[0];
    }
    async insert(table, data, _upsert = false) {
        let sql = `INSERT INTO ${this.strWrap(table)}`;
        const values = [];
        const rows = !Array.isArray(data) ? [data] : data;
        assert_1.default.ok(rows.length > 0, 'There must be atleast one row to insert.');
        const firstRow = rows[0];
        const firstRowKeys = Object.keys(firstRow);
        const valuePlaceholder = '(' + firstRowKeys.map((_) => '?').join(', ') + ')';
        // Append the columns that will be updated based on the first object.
        sql += ' (';
        sql += firstRowKeys.map((k) => this.strWrap(k)).join(', ');
        sql += ') VALUES ';
        sql += rows
            .map((row) => {
            values.push(...Object.values(row));
            return valuePlaceholder;
        })
            .join(', ');
        if (_upsert) {
            sql += ' ON DUPLICATE KEY UPDATE ';
            sql += firstRowKeys
                .map((k) => {
                const col = this.strWrap(k);
                return `${col} = COALESCE(VALUES(${col}), ${col})`;
            })
                .join(', ');
        }
        return this.execute(sql, values);
    }
    async update(table, data, cond, opts) {
        let sql = 'UPDATE ' + this.strWrap(table) + ' SET';
        const values = [];
        const keys = Object.keys(data);
        if (!keys.length) {
            return;
        }
        sql +=
            ' ' +
                keys
                    .map((k) => {
                    values.push(data[k]);
                    return this.strWrap(k) + ' = ?';
                })
                    .join(', ');
        if (cond) {
            sql += this.applyWhereCondition(cond, values);
        }
        if (opts === null || opts === void 0 ? void 0 : opts.order) {
            sql += this.applyOrder(opts.order);
        }
        if (opts === null || opts === void 0 ? void 0 : opts.limit) {
            sql += this.applyLimit(values, opts.limit);
        }
        if (opts === null || opts === void 0 ? void 0 : opts.offset) {
            throw new Error('offset not supported on updates using MySQL');
        }
        return this.execute(sql, values);
    }
    async upsert(table, data) {
        return this.insert(table, data, true);
    }
    async delete(table, cond, opts) {
        let sql = 'DELETE';
        const values = [];
        sql += ' FROM ' + this.strWrap(table);
        if (cond) {
            sql += this.applyWhereCondition(cond, values);
        }
        if (opts === null || opts === void 0 ? void 0 : opts.order) {
            sql += this.applyOrder(opts.order);
        }
        if (opts === null || opts === void 0 ? void 0 : opts.limit) {
            sql += this.applyLimit(values, opts.limit);
        }
        if (opts === null || opts === void 0 ? void 0 : opts.offset) {
            throw new Error('offset not supported on deletes using MySQL');
        }
        return this.execute(sql, values);
    }
    async getLastInsertId() {
        if (this.isPool(this.driver)) {
            throw new Error('getLastInsertId is not predictable on pool connection, use a normal connection or transaction instead.');
        }
        const [row] = await this.execute('SELECT LAST_INSERT_ID() as id');
        if (!row || row.id === 0) {
            throw new Error('No LAST_INSERT_ID found');
        }
        return row.id;
    }
    // Protected below...
    strWrap(str, char = '`') {
        return `${char}${str}${char}`;
    }
    applyWhereCondition(cond, values) {
        return (' WHERE ' +
            Object.keys(cond)
                .map((k) => {
                if (cond[k] === null) {
                    return '`' + k + '` IS NULL';
                }
                values.push(cond[k]);
                return '`' + k + '`' + (Array.isArray(cond[k]) ? ' IN(?)' : ' = ?');
            })
                .join(' AND '));
    }
    applyOrder(order) {
        const orderings = Array.isArray(order[0])
            ? order
            : [order];
        return (' ORDER BY ' +
            orderings
                .map((o) => this.strWrap(o[0]) + ' ' + o[1].toUpperCase())
                .join(', '));
    }
    applyLimit(values, limit, offset) {
        let sql = '';
        if (offset) {
            sql += ' LIMIT ?, ?';
            values.push(offset, limit);
        }
        else {
            sql = ' LIMIT ?';
            values.push(limit);
        }
        return sql;
    }
    async execute(sql, values) {
        var _a, _b;
        const con = await this.getConnection();
        (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.onQuery) === null || _b === void 0 ? void 0 : _b.call(_a, sql, values, con.threadId);
        const [result] = await con.query(sql, values);
        this.closeConnection(con);
        return result;
    }
    async getConnection() {
        var _a, _b;
        let con;
        let isNewConnection = true;
        if (this.isPool(this.driver)) {
            con = await this.driver.getConnection();
            if (con.mysql2ExtendedAlreadyInited) {
                isNewConnection = false;
            }
            con.mysql2ExtendedAlreadyInited = true;
        }
        else {
            con = this.driver;
        }
        if (((_a = this.opts) === null || _a === void 0 ? void 0 : _a.onNewConnection) && isNewConnection) {
            await ((_b = this.opts) === null || _b === void 0 ? void 0 : _b.onNewConnection(con));
        }
        return con;
    }
    async closeConnection(con) {
        if (this.isPoolConnection(con)) {
            return con.release();
        }
    }
    isPool(driver) {
        return 'getConnection' in driver;
    }
    isPoolConnection(con) {
        return 'release' in con;
    }
}
exports.QueryBase = QueryBase;
