import type { Pool, Connection, PoolConnection } from 'mysql2/promise';
import type { GlobalOpts, BindValue, QueryInterface, Condition, Opts, OrderBy, Row, Col, SingleConnection } from './types';
export declare class QueryBase implements QueryInterface {
    protected driver: Pool | Connection | PoolConnection;
    protected opts?: GlobalOpts | undefined;
    constructor(driver: Pool | Connection | PoolConnection, opts?: GlobalOpts | undefined);
    query<RowT>(sql: string, values?: BindValue[]): Promise<RowT[]>;
    queryOne<RowT>(sql: string, values?: BindValue[]): Promise<RowT>;
    select<RowT extends Row>(tableOrCols: string | Col<RowT>[], tableOrCond?: string | Condition<RowT>, condOrOpts?: Condition<RowT> | Opts, opts?: Opts): Promise<RowT[]>;
    selectOne<RowT extends Row>(tableOrCols: string | Col<RowT>[], tableOrCond?: string | Condition<RowT>, condOrOpts?: Condition<RowT> | Opts, opts?: Opts): Promise<RowT>;
    insert<RowT>(table: string, data: RowT | RowT[], _upsert?: boolean): Promise<unknown>;
    update<RowT extends Row>(table: string, data: Partial<RowT>, cond?: Condition<RowT>, opts?: Opts): Promise<unknown>;
    upsert<RowT extends Row>(table: string, data: RowT): Promise<unknown>;
    delete<RowT extends Row>(table: string, cond?: Condition<RowT>, opts?: Opts): Promise<unknown>;
    getLastInsertId(): Promise<number>;
    protected strWrap(str: string, char?: string): string;
    protected applyWhereCondition(cond: Condition<any>, values: BindValue[]): string;
    protected applyOrder(order: OrderBy): string;
    protected applyLimit(values: BindValue[], limit: number, offset?: number): string;
    protected execute<RowT>(sql: string, values?: BindValue[]): Promise<RowT[]>;
    protected getConnection(): Promise<SingleConnection>;
    protected closeConnection(con: SingleConnection): Promise<void>;
    protected isPool(driver: Pool | Connection): driver is Pool;
    protected isPoolConnection(con: Connection | PoolConnection): con is PoolConnection;
}
